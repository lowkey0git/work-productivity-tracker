import streamlit as st
import requests
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import json
import time

# Configure page
st.set_page_config(
    page_title="Blog Performance Tracker",
    page_icon="üìù",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for modern styling
st.markdown("""
<style>
    .main > div {
        padding-top: 2rem;
    }

    .stMetric {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 1rem;
        border-radius: 10px;
        color: white;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .stMetric label {
        color: white !important;
    }

    .stMetric div {
        color: white !important;
    }

    .status-card {
        padding: 1rem;
        border-radius: 10px;
        margin: 0.5rem 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .on-schedule {
        background: linear-gradient(135deg, #4CAF50, #45a049);
        color: white;
    }

    .acceptable {
        background: linear-gradient(135deg, #FF9800, #F57C00);
        color: white;
    }

    .poor-timing {
        background: linear-gradient(135deg, #F44336, #D32F2F);
        color: white;
    }

    .sidebar .stSelectbox > div > div {
        background-color: #f8f9fa;
    }

    .prediction-result {
        padding: 1.5rem;
        border-radius: 15px;
        margin: 1rem 0;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        color: white;
    }

    .api-status {
        padding: 1rem;
        border-radius: 10px;
        margin: 1rem 0;
        text-align: center;
        font-weight: bold;
    }

    .api-healthy {
        background: linear-gradient(135deg, #56ab2f, #a8e6cf);
        color: white;
    }

    .api-error {
        background: linear-gradient(135deg, #ff416c, #ff4757);
        color: white;
    }
</style>
""", unsafe_allow_html=True)

# Configuration
API_BASE_URL = "http://localhost:8000"


class BlogTrackerAPI:
    def __init__(self, base_url):
        self.base_url = base_url

    def health_check(self):
        try:
            response = requests.get(f"{self.base_url}/health", timeout=5)
            return response.status_code == 200, response.json() if response.status_code == 200 else None
        except requests.exceptions.RequestException as e:
            return False, str(e)

    def train_model(self):
        try:
            response = requests.post(f"{self.base_url}/train", timeout=30)
            return response.status_code == 200, response.json() if response.status_code == 200 else response.text
        except requests.exceptions.RequestException as e:
            return False, str(e)

    def predict_performance(self, data):
        try:
            response = requests.post(f"{self.base_url}/predict", json=data, timeout=10)
            return response.status_code == 200, response.json() if response.status_code == 200 else response.text
        except requests.exceptions.RequestException as e:
            return False, str(e)

    def get_posts_timeframe(self, start_time, end_time):
        try:
            data = {
                "start_time": start_time.isoformat(),
                "end_time": end_time.isoformat()
            }
            response = requests.post(f"{self.base_url}/posts/timeframe", json=data, timeout=10)
            return response.status_code == 200, response.json() if response.status_code == 200 else response.text
        except requests.exceptions.RequestException as e:
            return False, str(e)

    def get_model_performance(self):
        try:
            response = requests.get(f"{self.base_url}/model/performance", timeout=10)
            return response.status_code == 200, response.json() if response.status_code == 200 else response.text
        except requests.exceptions.RequestException as e:
            return False, str(e)

    def get_debug_info(self):
        try:
            response = requests.get(f"{self.base_url}/debug/data-info", timeout=10)
            return response.status_code == 200, response.json() if response.status_code == 200 else response.text
        except requests.exceptions.RequestException as e:
            return False, str(e)


# Initialize API client
api = BlogTrackerAPI(API_BASE_URL)


def main():
    # Header
    st.markdown("""
    <div style='text-align: center; padding: 2rem 0;'>
        <h1 style='background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                   -webkit-background-clip: text; -webkit-text-fill-color: transparent; 
                   font-size: 3rem; font-weight: bold; margin-bottom: 0.5rem;'>
            üìù Blog Performance Tracker
        </h1>
        <p style='font-size: 1.2rem; color: #666; margin-top: 0;'>
            AI-Powered Blog Post Performance Analysis & Prediction
        </p>
    </div>
    """, unsafe_allow_html=True)

    # Sidebar
    with st.sidebar:
        st.markdown("### üéõÔ∏è Control Panel")

        # API Status Check
        st.markdown("#### üì° API Status")
        if st.button("üîç Check API Status", use_container_width=True):
            with st.spinner("Checking API status..."):
                is_healthy, health_data = api.health_check()
                if is_healthy:
                    st.markdown(f"""
                    <div class='api-status api-healthy'>
                        ‚úÖ API is Healthy<br>
                        Model Trained: {'Yes' if health_data.get('model_trained') else 'No'}
                    </div>
                    """, unsafe_allow_html=True)
                else:
                    st.markdown(f"""
                    <div class='api-status api-error'>
                        ‚ùå API Error<br>
                        {health_data}
                    </div>
                    """, unsafe_allow_html=True)

        # Navigation
        st.markdown("#### üß≠ Navigation")
        page = st.selectbox(
            "Choose a page:",
            [
                "üè† Dashboard",
                "üîÆ Performance Prediction",
                "üìä Data Analysis",
                "ü§ñ Model Training",
                "üìà Model Performance",
                "üîß Debug Info"
            ]
        )

    # Main content based on selected page
    if page == "üè† Dashboard":
        show_dashboard()
    elif page == "üîÆ Performance Prediction":
        show_prediction_page()
    elif page == "üìä Data Analysis":
        show_data_analysis()
    elif page == "ü§ñ Model Training":
        show_training_page()
    elif page == "üìà Model Performance":
        show_model_performance()
    elif page == "üîß Debug Info":
        show_debug_info()


def show_dashboard():
    st.markdown("## üìä Dashboard Overview")

    # Quick stats row
    col1, col2, col3, col4 = st.columns(4)

    # Get recent data for dashboard
    end_time = datetime.now()
    start_time = end_time - timedelta(days=30)  # Last 30 days

    success, data = api.get_posts_timeframe(start_time, end_time)

    if success:
        with col1:
            st.metric(
                label="üìù Total Posts (30d)",
                value=data['total_posts'],
                delta="Last 30 days"
            )

        with col2:
            on_schedule = data['posts_by_status'].get('on_schedule', 0)
            total = data['total_posts']
            percentage = (on_schedule / total * 100) if total > 0 else 0
            st.metric(
                label="‚è∞ On Schedule",
                value=f"{percentage:.1f}%",
                delta=f"{on_schedule} posts"
            )

        with col3:
            poor_timing = data['posts_by_status'].get('poor_timing', 0)
            st.metric(
                label="‚ö†Ô∏è Poor Timing",
                value=poor_timing,
                delta="Posts with issues"
            )

        with col4:
            acceptable = data['posts_by_status'].get('acceptable', 0)
            st.metric(
                label="‚úÖ Acceptable",
                value=acceptable,
                delta="Decent performance"
            )

        # Status distribution chart
        if data['total_posts'] > 0:
            st.markdown("### üìà Performance Distribution")

            status_data = data['posts_by_status']

            # Create a donut chart
            fig = go.Figure(data=[go.Pie(
                labels=list(status_data.keys()),
                values=list(status_data.values()),
                hole=.3,
                marker_colors=['#4CAF50', '#FF9800', '#F44336']
            )])

            fig.update_layout(
                title="Blog Post Performance Distribution",
                font=dict(size=14),
                showlegend=True,
                height=400
            )

            st.plotly_chart(fig, use_container_width=True)

        # Recent posts timeline
        if data['posts_data']:
            st.markdown("### üìÖ Recent Posts Timeline")
            df = pd.DataFrame(data['posts_data'])
            df['post_published'] = pd.to_datetime(df['post_published'])

            fig = px.scatter(
                df,
                x='post_published',
                y='posting_status',
                color='posting_status',
                size='writing_duration',
                hover_data=['posting_delay', 'early_posting'],
                title="Recent Blog Posts Timeline",
                color_discrete_map={
                    'on_schedule': '#4CAF50',
                    'acceptable': '#FF9800',
                    'poor_timing': '#F44336'
                }
            )

            fig.update_layout(height=400)
            st.plotly_chart(fig, use_container_width=True)

    else:
        st.warning("üì° Unable to fetch dashboard data. Please check API connection.")


def show_prediction_page():
    st.markdown("## üîÆ Blog Post Performance Prediction")
    st.markdown("Enter your blog post timing details to predict performance:")

    col1, col2 = st.columns(2)

    with col1:
        st.markdown("### ‚úçÔ∏è Writing Details")
        start_writing = st.datetime_input(
            "When did you start writing?",
            value=datetime.now() - timedelta(hours=2),
            help="The timestamp when you began writing the post"
        )

        post_published = st.datetime_input(
            "When was the post published?",
            value=datetime.now(),
            help="The actual publication timestamp"
        )

    with col2:
        st.markdown("### üìÖ Schedule Details")
        scheduled_start = st.datetime_input(
            "When were you scheduled to start?",
            value=datetime.now() - timedelta(hours=3),
            help="Your planned start time for writing"
        )

        scheduled_deadline = st.datetime_input(
            "What was the deadline?",
            value=datetime.now() - timedelta(minutes=30),
            help="Your planned publication deadline"
        )

    # Validation
    if start_writing >= post_published:
        st.error("‚ö†Ô∏è Start writing time must be before publication time!")
        return

    if scheduled_start >= scheduled_deadline:
        st.error("‚ö†Ô∏è Scheduled start must be before scheduled deadline!")
        return

    if st.button("üîÆ Predict Performance", use_container_width=True, type="primary"):
        with st.spinner("ü§ñ Analyzing your blog post performance..."):
            prediction_data = {
                "start_writing": start_writing.isoformat(),
                "post_published": post_published.isoformat(),
                "scheduled_start": scheduled_start.isoformat(),
                "scheduled_deadline": scheduled_deadline.isoformat()
            }

            success, result = api.predict_performance(prediction_data)

            if success:
                # Display prediction result
                status = result['predicted_status']
                probabilities = result['probabilities']

                # Status styling
                status_colors = {
                    'on_schedule': '#4CAF50',
                    'acceptable': '#FF9800',
                    'poor_timing': '#F44336'
                }

                status_icons = {
                    'on_schedule': 'üéØ',
                    'acceptable': '‚ö°',
                    'poor_timing': '‚ö†Ô∏è'
                }

                st.markdown(f"""
                <div class='prediction-result'>
                    <h2 style='margin-top: 0; text-align: center;'>
                        {status_icons.get(status, 'üìä')} Prediction Result
                    </h2>
                    <h1 style='text-align: center; margin: 1rem 0; font-size: 2.5rem;'>
                        {status.replace('_', ' ').title()}
                    </h1>
                    <p style='text-align: center; opacity: 0.9;'>
                        Model Used: {result['model_used']}
                    </p>
                </div>
                """, unsafe_allow_html=True)

                # Probability breakdown
                st.markdown("### üìä Confidence Breakdown")
                prob_df = pd.DataFrame(list(probabilities.items()), columns=['Status', 'Probability'])
                prob_df['Probability'] = prob_df['Probability'] * 100
                prob_df = prob_df.sort_values('Probability', ascending=False)

                fig = px.bar(
                    prob_df,
                    x='Status',
                    y='Probability',
                    color='Status',
                    color_discrete_map=status_colors,
                    title="Prediction Confidence for Each Status"
                )

                fig.update_layout(
                    yaxis_title="Confidence (%)",
                    xaxis_title="Performance Status",
                    height=400
                )

                st.plotly_chart(fig, use_container_width=True)

            else:
                st.error(f"‚ùå Prediction failed: {result}")


def show_data_analysis():
    st.markdown("## üìä Data Analysis")

    # Time range selector
    col1, col2 = st.columns(2)
    with col1:
        start_date = st.date_input(
            "Start Date",
            value=datetime.now().date() - timedelta(days=30)
        )

    with col2:
        end_date = st.date_input(
            "End Date",
            value=datetime.now().date()
        )

    if st.button("üìà Analyze Data", use_container_width=True):
        start_datetime = datetime.combine(start_date, datetime.min.time())
        end_datetime = datetime.combine(end_date, datetime.max.time())

        with st.spinner("üîç Analyzing your data..."):
            success, data = api.get_posts_timeframe(start_datetime, end_datetime)

            if success:
                st.success(f"‚úÖ Found {data['total_posts']} posts in the selected timeframe")

                if data['total_posts'] > 0:
                    # Convert to DataFrame for analysis
                    df = pd.DataFrame(data['posts_data'])
                    df['post_published'] = pd.to_datetime(df['post_published'])
                    df['posting_hour'] = df['post_published'].dt.hour
                    df['posting_day'] = df['post_published'].dt.day_name()

                    # Performance by hour
                    st.markdown("### ‚è∞ Performance by Hour of Day")
                    hourly_perf = df.groupby(['posting_hour', 'posting_status']).size().unstack(fill_value=0)

                    fig = px.bar(
                        hourly_perf.reset_index(),
                        x='posting_hour',
                        y=['on_schedule', 'acceptable', 'poor_timing'],
                        title="Blog Post Performance by Hour of Day",
                        labels={'value': 'Number of Posts', 'posting_hour': 'Hour of Day'},
                        color_discrete_map={
                            'on_schedule': '#4CAF50',
                            'acceptable': '#FF9800',
                            'poor_timing': '#F44336'
                        }
                    )
                    st.plotly_chart(fig, use_container_width=True)

                    # Performance by day of week
                    st.markdown("### üìÖ Performance by Day of Week")
                    daily_perf = df.groupby(['posting_day', 'posting_status']).size().unstack(fill_value=0)

                    # Reorder days
                    day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
                    daily_perf = daily_perf.reindex(day_order, fill_value=0)

                    fig = px.bar(
                        daily_perf.reset_index(),
                        x='posting_day',
                        y=['on_schedule', 'acceptable', 'poor_timing'],
                        title="Blog Post Performance by Day of Week",
                        color_discrete_map={
                            'on_schedule': '#4CAF50',
                            'acceptable': '#FF9800',
                            'poor_timing': '#F44336'
                        }
                    )
                    st.plotly_chart(fig, use_container_width=True)

                    # Writing duration vs performance
                    st.markdown("### ‚è±Ô∏è Writing Duration Impact")
                    fig = px.box(
                        df,
                        x='posting_status',
                        y='writing_duration',
                        color='posting_status',
                        title="Writing Duration by Performance Status",
                        color_discrete_map={
                            'on_schedule': '#4CAF50',
                            'acceptable': '#FF9800',
                            'poor_timing': '#F44336'
                        }
                    )
                    st.plotly_chart(fig, use_container_width=True)

                    # Data table
                    st.markdown("### üìã Raw Data")
                    st.dataframe(
                        df[['post_published', 'posting_status', 'writing_duration', 'posting_delay', 'early_posting']],
                        use_container_width=True)

            else:
                st.error(f"‚ùå Failed to fetch data: {data}")


def show_training_page():
    st.markdown("## ü§ñ Model Training")
    st.markdown("Train the machine learning model with your latest data:")

    col1, col2 = st.columns([2, 1])

    with col1:
        st.info("""
        **üéØ What happens during training:**
        - Loads your blog post data from CSV
        - Preprocesses and engineers features
        - Trains a RandomForest model with GridSearchCV
        - Optimizes hyperparameters automatically
        - Validates performance on test data
        """)

    with col2:
        if st.button("üöÄ Start Training", use_container_width=True, type="primary"):
            with st.spinner("ü§ñ Training your model... This may take a few minutes."):
                success, result = api.train_model()

                if success:
                    st.success("‚úÖ Model training completed successfully!")

                    # Display training results
                    if result.get('model_performance'):
                        perf = result['model_performance'][0]

                        col_a, col_b, col_c = st.columns(3)

                        with col_a:
                            st.metric(
                                "üéØ Test Accuracy",
                                f"{perf['test_accuracy']:.3f}",
                                delta=f"CV: {perf['best_cv_score']:.3f}"
                            )

                        with col_b:
                            st.metric(
                                "üèãÔ∏è Training Samples",
                                perf['train_samples']
                            )

                        with col_c:
                            st.metric(
                                "‚úÖ Test Samples",
                                perf['test_samples']
                            )

                        # Best parameters
                        st.markdown("### ‚öôÔ∏è Optimized Parameters")
                        st.json(perf['best_parameters'])

                else:
                    st.error(f"‚ùå Training failed: {result}")


def show_model_performance():
    st.markdown("## üìà Model Performance Metrics")

    if st.button("üìä Get Performance Metrics", use_container_width=True):
        with st.spinner("üìä Fetching model performance..."):
            success, result = api.get_model_performance()

            if success:
                perf = result['model_performance'][0]

                # Main metrics
                col1, col2, col3, col4 = st.columns(4)

                with col1:
                    st.metric(
                        "üéØ Test Accuracy",
                        f"{perf['test_accuracy']:.4f}"
                    )

                with col2:
                    st.metric(
                        "üîÑ CV Score",
                        f"{perf['best_cv_score']:.4f}"
                    )

                with col3:
                    st.metric(
                        "üß† Model",
                        result['best_model']
                    )

                with col4:
                    st.metric(
                        "üìä Features",
                        result['total_features_after_encoding']
                    )

                # Feature importance (if available)
                st.markdown("### üéØ Feature Columns Used")
                features_df = pd.DataFrame({'Feature': result['feature_columns']})
                st.dataframe(features_df, use_container_width=True)

                # Best parameters
                st.markdown("### ‚öôÔ∏è Optimized Hyperparameters")
                st.json(perf['best_parameters'])

                # Training summary
                st.markdown("### üìã Training Summary")
                st.write(f"- **Training Samples:** {perf['train_samples']}")
                st.write(f"- **Test Samples:** {perf['test_samples']}")
                st.write(f"- **Model Type:** {perf['model']}")
                st.write(f"- **Cross-Validation Folds:** 3")

            else:
                st.error(f"‚ùå Failed to get performance metrics: {result}")


def show_debug_info():
    st.markdown("## üîß Debug Information")
    st.markdown("Technical information about your data and system:")

    if st.button("üîç Get Debug Info", use_container_width=True):
        with st.spinner("üîç Gathering debug information..."):
            success, result = api.get_debug_info()

            if success:
                # Data shape and columns
                col1, col2 = st.columns(2)

                with col1:
                    st.markdown("### üìä Data Shape")
                    st.write(f"**Rows:** {result['data_shape'][0]}")
                    st.write(f"**Columns:** {result['data_shape'][1]}")

                    st.markdown("### üèóÔ∏è Preprocessed Shape")
                    st.write(f"**Rows:** {result['preprocessed_shape'][0]}")
                    st.write(f"**Columns:** {result['preprocessed_shape'][1]}")

                with col2:
                    st.markdown("### üìà Status Distribution")
                    status_dist = result['status_distribution']
                    for status, count in status_dist.items():
                        st.write(f"**{status.replace('_', ' ').title()}:** {count}")

                # Columns info
                st.markdown("### üìã Data Columns")
                columns_df = pd.DataFrame({
                    'Column': result['columns'],
                    'Data Type': [str(dtype) for dtype in result['data_types'].values()]
                })
                st.dataframe(columns_df, use_container_width=True)

                # Null counts
                st.markdown("### ‚ùå Missing Values")
                null_counts = result['null_counts']
                if any(count > 0 for count in null_counts.values()):
                    null_df = pd.DataFrame(list(null_counts.items()), columns=['Column', 'Null Count'])
                    null_df = null_df[null_df['Null Count'] > 0]
                    st.dataframe(null_df, use_container_width=True)
                else:
                    st.success("‚úÖ No missing values found!")

                # Feature statistics
                st.markdown("### üìä Feature Statistics")
                feature_stats = result['feature_stats']
                stats_df = pd.DataFrame(feature_stats).transpose()
                st.dataframe(stats_df, use_container_width=True)

                # Sample data
                st.markdown("### üëÄ Sample Data")
                sample_df = pd.DataFrame(result['first_few_rows'])
                st.dataframe(sample_df, use_container_width=True)

            else:
                st.error(f"‚ùå Failed to get debug info: {result}")


if __name__ == "__main__":
    main()
